<h1 id="einleitung">Einleitung</h1>
<p>Eine Möglichkeit Daten so geordnet zu speichern sind so genannte Baumdatenstrukturen. Diese Speichern Werte geordnet nach einem bestimmten Schlüssel. Eine sehr einfache Baumimplemntierung ist der <span data-acronym-label="bt" data-acronym-form="singular+short">bt</span> welcher jeweils nur 2 Abzweigungen pro Knoten besitzt (rigorose Baumdefinition in Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a>). Leider hat diese naiive Variante der Datenstruktur einige Probleme, welche vorallem beim Einfügen der Daten in geordneter Reigenfolge entstehen. Um diese Probleme zu umgehen kann man die Algorithmen zum Einfügen und Entfernen neuer Datensätze so anpassen, dass die Baumstruktur performanter wird. Ein möglicher besserer Ansatz sind die <span data-acronym-label="rbt" data-acronym-form="plural+short">rbts</span>.</p>
<p>Diese Arbeit beschreibt wie sich <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> von normalen <span data-acronym-label="bt" data-acronym-form="plural+short">bts</span> unterscheiden. Es wird ausführlich beschrieben, wie normale <span data-acronym-label="bt" data-acronym-form="plural+short">bts</span> funktionieren und wie man ihre Algorithmen erweitert um <span data-acronym-label="rbt" data-acronym-form="plural+short">rbts</span> zu erhalten. Dazu wurden jeweils beide <span data-acronym-label="dt" data-acronym-form="plural+short">dts</span> in der Programmiersprache <strong>C</strong><span class="math inline"> </span>implementiert. Auf den jeweiligen <span data-acronym-label="sc" data-acronym-form="singular+short">sc</span> wird auch eingegangen um auf bestimmte Schwierigkeiten und Besonderheiten und den Implementierungen einzugehen. Zudem werden die Ergenisse von <span data-acronym-label="bm" data-acronym-form="singular+short">bm</span> analysiert, welche zeigen sollen, dass <span data-acronym-label="rbt" data-acronym-form="plural+short">rbts</span> tatsächlich besser Laufzeiteigenschaften haben als die Standimplementierung der <span data-acronym-label="bt" data-acronym-form="plural+short">bts</span>. Außerdem wird auf die Speicher- und Zeitkomplexität der beiden <span data-acronym-label="dt" data-acronym-form="plural+short">dts</span> eingegangen und wie sich vorallem der <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> im <span data-acronym-label="wc" data-acronym-form="singular+short">wc</span> verhält.</p>
<h1 id="def">Definition Binary Tree &amp; Red Black Tree</h1>
<h1 id="implementierung">Implementierung</h1>
<p>Wie schon in den vorhergenden Kapiteln beschrieben, handelt es sich bei den Bäumen um eine generische Datenstruktur, in die der Nutzer beliebig Daten mit einem bestimmten Schlüssel einfügen kann.</p>
<p>Die Implementierung stellt deswegen 3 Funktionen bereit, mit denen man nach einem bestimmten Schlüssel im Baum suchen kann, man einen neuen Schlüssel zusammen mit einem Datensatz einfügen kann und man einen Schlüssel und den Datensatz wieder aus dem Baum löschen kann.</p>
<h2 id="generics-in-c">Generics in C</h2>
<p>Bei der Implementierung in <strong>C</strong><span class="math inline"> </span>gab es dabei einige Schwierigkeiten, die man lösen musste. Es beginnt damit, dass <strong>C</strong><span class="math inline"> </span>keine objekt-orientierte Programmiersprache ist und keine eingebaute Möglichkeit für <span data-acronym-label="gns" data-acronym-form="plural+short">gnss</span> hat. Nun kann man dieses Problem auf verschiedene Weisen lösen. Den Wert, der bei jedem Knoten des Baums gespeichert werden soll, lässt sich ganz simple aus Void-Pointer (<code class="sourceCode c"><span class="dt">void</span>*</code>) implementieren, sodass man die Daten beispielsweise auf dem <span data-acronym-label="hp" data-acronym-form="singular+short">hp</span> ablegen kann und mithilfe eines Casts den Pointer der Daten (z.B. <code class="sourceCode c"><span class="dt">int</span>*</code>) zu <code class="sourceCode c"><span class="dt">void</span>*</code> umwandeln kann. Das erlaubt es, beliebige Datentypen und sogar <span data-acronym-label="sts" data-acronym-form="singular+short">sts</span> in den Baum einzufügen. Diese Variante ist möglich, da die Nutzerdaten auf die Suche nach einem Knoten keinen Einfluss haben.</p>
<p>Anders ist es bei der Implementierung der Schlüssel. Hier muss sichergestellt sein, dass diese untereinander vergleichbar sind, sodass man die Suche, wie im Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a> beschrieben, durchführen kann. Man könnte Gebrauch von <span data-acronym-label="uns" data-acronym-form="plural+short">unss</span> in <strong>C</strong><span class="math inline"> </span>machen, in denen man die numerischen Datentypen als mögliche Schlüssel anbietet.</p>
<div class="sourceCode" id="cb1" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">union</span> RBTreeKey {</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">char</span> c;</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">short</span> s;</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">long</span> <span class="dt">long</span> l;</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="dt">float</span> f;</a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="dt">double</span> d;</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>Zusätzlich müsste man dazu noch angeben, welchen Datentyp man in seinem Code nutzt (z.B. mithilfe einer <span data-acronym-label="mc" data-acronym-form="singular+short">mc</span>). Dieser Ansatz ist allerdings sehr unflexibel, weil man auf die Datentypen, die im <code class="sourceCode c"><span class="kw">union</span> RBTreeKey</code> vom Programmierer festgelegt sind, beschränkt ist.</p>
<p>Ein bessere Ansatz ist es, eine <span data-acronym-label="mc" data-acronym-form="singular+short">mc</span> zu definieren, die den Typen der Schlüssel definiert. Zusätzlich kann man noch eine 2. und 3. <span data-acronym-label="mc" data-acronym-form="singular+short">mc</span> definieren, die die Kleiner-Als- und Ist-Gleich-Operatoren definieren. Das ermöglicht es beliebige Datentypen als Schlüssel zu verwenden (sogar <span data-acronym-label="sts" data-acronym-form="plural+short">stss</span>), solange man die Vergleichsmacros definieren kann.</p>
<div class="sourceCode" id="cb2" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#define T int</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#define TEQUAL(x, y) ((x) == (y))</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="pp">#define TLESS(x, y) ((x) &lt; (y))</span></a></code></pre></div>
<p>Genau diese Implementierung wurde auch gewählt. Im Usercode müssen nur der Typ T und die Vergleichsoperationen TLESS und TEQUAL definiert werden. Einziger Nachteil ist, dass man im selben <span data-acronym-label="sc" data-acronym-form="singular+short">sc</span> nicht meherere verschidene Varianten von Schlüsseldatentypen nutzen kann.</p>
<h2 id="knoten-als-struct">Knoten als Struct</h2>
<p>Wie schon in Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a> beschrieben, sind Bäume nichts anders als ein 3-Tupel <span class="math inline">(<em>l</em>, <em>k</em>, <em>r</em>)</span>. <span class="math inline"><em>l</em></span> und <span class="math inline"><em>r</em></span> sind die Unterbäume und <span class="math inline"><em>k</em></span> ist die Wurzel des Baumes (hier als <span class="math inline"><em>k</em></span> bezeichnet wegen Schlüssel <span class="math inline">$\widehat{=}$</span> Key). Jeder Knoten enthält somit seinen Schlüssel und eine Referenz auf den linken und rechten Unterbaum. In <strong>C</strong><span class="math inline"> </span>wird der Baum nun als verkettete Liste von Knoten dargestellt . Im <code class="sourceCode c"><span class="kw">struct</span> Node</code> haben wir somit den generischen Schlüssel <code class="sourceCode c">T *key</code> und zugehörigen Wert <code class="sourceCode c"><span class="dt">void</span> *value</code>. Zusätzlich speichern wir Pointer zum linken und rechten Child, welche die Wurzeln der entsprechenden Unterbäume sind. Zusätzlich wird auch noch ein Pointer zum Parent gespiechert, da man diesen ziemlich oft in den Algorithmen zum Einfügen und Löschen von Knoten benötogt und man so den Quellcode etwas vereinfachen kann.</p>
<p>Natürlich gibt es im Knoten auch noch ein Feld, welches die Farbe des Knotens speichert. Diese ist später wichtig, weil sie von zum balancieren des Baumes benötigt wird. Dieses findet während des Einfügens und Löschens neuer Knoten in den Baum statt. Die Werte für dieses Feld im <span data-acronym-label="sts" data-acronym-form="singular+short">sts</span> werden durch die <span data-acronym-label="mc" data-acronym-form="plural+short">mcs</span> <code class="sourceCode c">RB_TREE_RED</code> und <code class="sourceCode c">RB_TREE_BLACK</code> definiert.</p>
<p>Zusätzlich existiert ein weiter <span data-acronym-label="sts" data-acronym-form="singular+short">sts</span> für den Baum selbst, welcher allerdings nur als Handle für die Funktionen dient. Er speichert die Wurzel und die Anzahl der eingefügten Knoten. Diese wird benötigt, damit man die <span data-acronym-label="wch" data-acronym-form="singular+short">wch</span> des Baums berechnen kann .</p>
<div class="sourceCode" id="cb3" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#define RB_TREE_RED     1U</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="pp">#define RB_TREE_BLACK   0U</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">struct</span> Node;</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">struct</span> Node {</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="dt">void</span> *value;</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9">    T *key;</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="kw">struct</span> Node *left;</a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="kw">struct</span> Node *right;</a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="kw">struct</span> Node *parent;</a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="dt">uint8_t</span> color;</a>
<a class="sourceLine" id="cb3-16" title="16">};</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="kw">struct</span> RBTree {</a>
<a class="sourceLine" id="cb3-19" title="19">    <span class="kw">struct</span> Node *root;</a>
<a class="sourceLine" id="cb3-20" title="20"></a>
<a class="sourceLine" id="cb3-21" title="21">    <span class="dt">size_t</span> node_count;</a>
<a class="sourceLine" id="cb3-22" title="22">};</a></code></pre></div>
<p>Zusätzlich existieren 2 Helfer-Funktionen, die jeweils eine Instanz von diesem <span data-acronym-label="sts" data-acronym-form="singular+short">sts</span> für den Nutzer erstellen und auch wieder freigeben. Der Baum wird durch die <code class="sourceCode c">create_tree</code> Funktion auf dem Heap abgespeichert und aus wird lediglich ein Pointer zu ihr ausgegeben. Das Löschen des Baumes wird durch <code class="sourceCode c">free_tree</code> implementiert. Dieses ist auch auf keinen Fall trivial, weil es Bottom-Up durchgeführt werden muss und somit nicht durch den Nutzer selbst implementiert werden sollte.</p>
<p>Die Signatur dieser Funktionen sieht man im unteren Listing.</p>
<div class="sourceCode" id="cb4" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">struct</span> RBTree* create_tree();</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">void</span> free_tree(<span class="kw">struct</span> RBTree *rbtree);</a></code></pre></div>
<h2 id="sea">Suche nach Knoten</h2>
<p>Eine der wichtigsten Operation, auf die auch später das Einfügen und das Löschen von Knoten aufbaut ist die Suche im Baum. Diese ist normalerweise als rekursiver Algorithmus definiert, lässt sich aber auch ziemlich einfach iterativ implementieren. Grundsätzlich wurde in der Implementierung auf <span data-acronym-label="rec" data-acronym-form="singular+short">rec</span> verzichtet und immer entweder ein iterativer Ansatz verwendet oder ein selbst implementierter <span data-acronym-label="st" data-acronym-form="singular+short">st</span>, um <span data-acronym-label="sof" data-acronym-form="plural+short">sofs</span> zu vermeiden.</p>
<p>Die Funktion, die die Suche implementiert, akzeptiert eine Pointer zum Baum, den zu suchenden Schlüssel und einen Pointer, in der der Pointer des gefundenen Knotens geschrieben werden kann, falls vorhanden.</p>
<div class="sourceCode" id="cb5" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">uint8_t</span> search_node(<span class="kw">struct</span> RBTree* rbtree, T* key, <span class="kw">struct</span> Node** node);</a></code></pre></div>
<p>Der Algorithmus selbst speichert den aktuellen Knoten in der Variable <code class="sourceCode c"><span class="kw">struct</span> Node* current</code> beginnend bei der Wurzel. Anschließen wird iterativ entweder der linke oder der rechte Unterbaum besucht, abhängig davon, ob der Schlüssel, nachdem gesucht wird, kleiner oder größer als der Schlüssel des aktuellen Knotens ist. Wenn er kleiner ist wird der linke Unterbaum besucht sonst der Rechte. Dies geschiet, in dem <code class="sourceCode c">current</code> entweder das linke oder rechte Child des aktuellen Knotens zugewisen wird.</p>
<p>Die <code class="sourceCode c"><span class="cf">while</span></code>-Schleife bricht ab, wenn der Schlüssel gefunden wurde oder das nächste Child <code class="sourceCode c">NULL</code> ist. Im letzteren Fall wird ein Fehlercode returned und dem Ausgabe Pointer <code class="sourceCode c">NULL</code> zugewiesen, weil der Schlüssel nicht im Baum vorhanden ist. Ansonsten kann man der Ausgabe einfach <code class="sourceCode c">current</code> zuweisen und den Erfolgswert returnen, der anzeigt, dass es keinen Fehler gab (mehr dazu in Kapitel <a href="#err" data-reference-type="ref" data-reference="err">3.7</a>).</p>
<div class="sourceCode" id="cb6" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> Node *current  = rbtree-&gt;root;</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="cf">while</span> (current != NULL) {</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="cf">if</span> (TEQUAL(*(current-&gt;key), *(key))) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb6-5" title="5">    current = (TLESS(*key, *(current-&gt;key))) ? current-&gt;left : current-&gt;right;</a>
<a class="sourceLine" id="cb6-6" title="6">}</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="cf">if</span> (current == NULL) {</a>
<a class="sourceLine" id="cb6-9" title="9">    *node = NULL;</a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="cf">return</span> RB_TREE_KEY_ERROR;</a>
<a class="sourceLine" id="cb6-11" title="11">}</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13">*node = current;</a>
<a class="sourceLine" id="cb6-14" title="14"><span class="cf">return</span> RB_TREE_SUCCESS;</a></code></pre></div>
<h2 id="einfügen-von-knoten">Einfügen von Knoten</h2>
<h3 id="einfügen-des-neuen-knotens">Einfügen des neuen Knotens</h3>
<p>Eine weiter wichtige Operation ist das Einfügen von Daten in den Baum. Dabei müssen die zwei Eigenschaften der Datenstruktur erhalten bleiben, die sortierte Reihenfolge und dass der Baum ein valider <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> ist. Das Listing unten zeigt die Signatur der Funktion, die das Einfügen durchführt. Sie akzeptiert einen Pointer zu einem Baumstruct <code class="sourceCode c"><span class="kw">struct</span> RBTree* rbtree</code>, einen Pointer zum Schlüssel des neuen Knotens <code class="sourceCode c">T* key</code> und optional Daten, die auch im Knoten gespeichert werden sollen, <code class="sourceCode c"><span class="dt">void</span>* value</code> (dieser Wert kann auch <code class="sourceCode c">NULL</code> sein).</p>
<div class="sourceCode" id="cb7" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">uint8_t</span> insert_node(<span class="kw">struct</span> RBTree* rbtree, T* key, <span class="dt">void</span>* value);</a></code></pre></div>
<p>Die Implementierung sorgt erst dafür, dass der neue Knoten an die richtige Stelle im Baum eingefügt wird und stellt danach (wenn nötig) sicher, dass es immer noch ein valider <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> ist.</p>
<p>Das Einfügen des Knotens in den Baum kann nun analog zur Suche implementiert werden. Der Unterschied liegt darin, dass man den Baum durchsucht, bis man bei <code class="sourceCode c">NULL</code> ankommt. Beim Suchen war das der Fehlerfall, dass es keinen Knoten mit dem zu suchenden Schlüssel gab, aber während des Einfügens ist das die Annahme die getroffen wird. Der Schlüssel, den den Nutzer neu hinzufügen will, sollte noch nicht im Baum enthalten sein. Damit ist der erreichte <code class="sourceCode c">NULL</code>-Pointer nach der Logik des Baums genau die Stelle, an der der neue Knoten mit dem neuen Schlüssel eingefügt werden muss.</p>
<p>Der Grund, warum hier der Pointer zum Vorgänger-Knoten <code class="sourceCode c">previous</code> zusätzlich gespeichert werden muss, ist, dass <code class="sourceCode c">NULL</code> nicht auf eine valide Structinstanz zeigt, sondern lediglich anzeigt, dass es keinen Knoten an dieser Stelle gibt. Somit kann man auch nicht den Parent von <code class="sourceCode c">NULL</code> abfragen und man muss diese Information in einer zustätzlichen Variable zwischenspeichern.</p>
<div class="sourceCode" id="cb8" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">struct</span> Node *previous = NULL;</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">struct</span> Node *current  = rbtree-&gt;root;</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="cf">while</span> (current != NULL) {</a>
<a class="sourceLine" id="cb8-5" title="5">    previous = current;</a>
<a class="sourceLine" id="cb8-6" title="6">    current  = (TLESS(*key, *(previous-&gt;key))) ? previous-&gt;left : previous-&gt;right;</a>
<a class="sourceLine" id="cb8-7" title="7">}</a></code></pre></div>
<p>Nun wird eine neue Instanz von <code class="sourceCode c"><span class="kw">struct</span> Node</code> erstellt. Das erledigt die Helfer-Funktion <code class="sourceCode c">_create_node</code>, welche den neuen Knoten auf dem Heap abspeichert und den Pointer auf ihn ausgibt. In ihr wird auch direkt sichergestellt, dass der neu allozierte <span data-acronym-label="hp" data-acronym-form="singular+short">hp</span>-Speicher korrekt initialisiert wird und die Farbe auf rot gesetzt. Der neue Knoten muss dann an den Parent vom erreichten <code class="sourceCode c">NULL</code>-Pointer entweder links oder rechts angehangen werden.</p>
<div class="sourceCode" id="cb9" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> Node *new_node = _create_node(key, value);</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="cf">if</span> (TLESS(*key, *(previous-&gt;key))) {</a>
<a class="sourceLine" id="cb9-3" title="3">    previous-&gt;left = new_node;</a>
<a class="sourceLine" id="cb9-4" title="4">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">    previous-&gt;right = new_node;</a>
<a class="sourceLine" id="cb9-6" title="6">}</a>
<a class="sourceLine" id="cb9-7" title="7">new_node-&gt;parent = previous;</a></code></pre></div>
<p>Es gibt auch noch den Spezialfall, dass ein Knoten in einen noch leeren <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> eingefügt werden soll. Hier muss dann der Pointer auf die Wurzel im <code class="sourceCode c"><span class="kw">struct</span> RBTree</code> gesetzt werden. Deswegen wird bevor der oben angebene Algorithmus ausgeführt wird, noch überprüft, ob der Nutzer den leeren Baum als Eingabe in die Funktion gegeben hat. Das Gute ist, dass man in diesem Fall auch gar nicht den Baum durchsuchen muss, sondern sofort weiß, dass der neue Knoten die Wurzel selbst ist. Es darf allerdings nicht vergessen werden, dass durch <code class="sourceCode c">_create_node</code> die Farbe des neuen Knotens auf rot gesetzt wurde. Sie muss deswegen noch zu schwarz geändert werden, weil die Wurzel des <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> immer schwarz sein muss.</p>
<div class="sourceCode" id="cb10" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="cf">if</span> (rbtree-&gt;root == NULL) {</a>
<a class="sourceLine" id="cb10-2" title="2">  rbtree-&gt;root = new_node;</a>
<a class="sourceLine" id="cb10-3" title="3">  rbtree-&gt;root-&gt;color = RB_TREE_BLACK;</a>
<a class="sourceLine" id="cb10-4" title="4">}</a></code></pre></div>
<h3 id="balancieren-des-baums-einfügen">Balancieren des Baums (Einfügen)</h3>
<p>Nach dem Einfügen in den Baum, kann es dazu kommen, dass die Regeln des <span data-acronym-label="rbt" data-acronym-form="plural+short">rbts</span> verletzt werden. Dieser Fall tritt dann ein, wenn der Parent des neuen Knotens rot ist, denn dann sind 2 aufeinanderfolgende rote Knoten im Baum, was nicht der Fall sein darf (siehe <a href="#def" data-reference-type="ref" data-reference="def">2</a>).</p>
<p>Wenn der obige Fall eintritt, muss einer der in Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a> beschriebenen Algorithmen ausgeführt werden, damit der Baum wieder alle Eigenschaften erfüllt und ein valider <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> wird. Das hat den Nebeneffekt, dass der Baum dabei besser im Durchschnitt ausbalanciert wird. In der Implementierung wurden Helferfunktionen implementiert, die den Colorflip und die Rotations am Baum durchführen.</p>
<p>Das untere Listing zeigt einen Auszug aus der Funktion, welche die Baumrotation durchführt (nur die Linksrotation).</p>
<div class="sourceCode" id="cb11" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">struct</span> Node *child = start_node-&gt;right;</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="cf">if</span> (start_node == rbtree-&gt;root) rbtree-&gt;root = child;</a>
<a class="sourceLine" id="cb11-3" title="3">child-&gt;parent = start_node-&gt;parent;</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="cf">if</span> (start_node-&gt;parent != NULL) {</a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="cf">if</span> (start_node-&gt;parent-&gt;left == start_node) start_node-&gt;parent-&gt;left = child;</a>
<a class="sourceLine" id="cb11-7" title="7">  <span class="cf">else</span> start_node-&gt;parent-&gt;right = child;</a>
<a class="sourceLine" id="cb11-8" title="8">}</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">start_node-&gt;right = child-&gt;left;</a>
<a class="sourceLine" id="cb11-11" title="11"><span class="cf">if</span> (start_node-&gt;right) start_node-&gt;right-&gt;parent = start_node;</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13">child-&gt;left = start_node;</a>
<a class="sourceLine" id="cb11-14" title="14">start_node-&gt;parent = child;</a></code></pre></div>
<p>Hier zeigt sich der Vorteil der Implementierung als Verkettung von Pointern. Die Rotation kann einfach durch das Austauschen von Child- und Parent-Pointern implementiert werden.</p>
<p>Nachdem die Helferfunktionen besprochen wurden, kann nun endlich mit dem rebalancieren begonnen werden, welches diese nutzt. Die Funktion, die diesen entsprechenden Algorithmus dafür implementiert heißt <code class="sourceCode c">fix_tree_insert</code>. Ihre Signatur befindet sich im unteren Listing.</p>
<div class="sourceCode" id="cb12" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span> fix_tree_insert(<span class="kw">struct</span> Node *start_node, <span class="kw">struct</span> RBTree *rbtree)</a></code></pre></div>
<p><code class="sourceCode c">start_node</code> ist dabei der Knoten, der die Eigenschaften eines <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> verletzt, also der Knoten, der zuletzt eingefügt wurde.</p>
<p>Unten kann man nun die Implementierung der Funktion sehen. Als erstes werden 2 Pointer angelegt, die den aktuell betrachteten Knoten und seinen Parent speichern. Das ist wichtig, weil es passieren kann, dass der Algorithmus mehrere Schritte benötigt. Das ist auch der Grund, warum sich alles innerhalb einer <code class="sourceCode c"><span class="cf">while</span></code>-Schleife befindet, nämlich damit solange rebalanciert wird, bis die Abbruchbediengung erreicht wird (siehe Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a>).</p>
<p>Wie schon in Kapitel <a href="#def" data-reference-type="ref" data-reference="def">2</a> beschrieben, gibt es verschiedene Fälle, die betrachtet werden müssen. Je nach Farbe des Uncle-Knotens und Richtung des Parents werden Colorflips und Rotationen durchgeführt. Dafür können hier nun die Helferfunktionen, die in den letzten Abschnitten beschrieben wurden genutzt werden. Der Vorteil daran ist, dass diese auch gleich noch bestimmte Fehlerfälle abfangen, sodass man sich viel Codeduplzierung ersparen kann.</p>
<p>Als letztes wird noch die Farbe der Wurzel auf <code class="sourceCode c">RB_TREE_BLACK</code> gesetzt, weil es vorkommen kann, dass sie am Ende rot ist. Die Eigenschaften von <span data-acronym-label="rbt" data-acronym-form="singular+short">rbt</span> schreiben jedoch vor, dass die Wurzel immer schwarz sein muss. Hier wurde bewusst auf eine <code class="sourceCode c"><span class="cf">if</span></code>-Abfrage verzichtet, um Instruktionen zu sparen.</p>
<div class="sourceCode" id="cb13" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">struct</span> Node *current = start_node;</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">struct</span> Node *parent = start_node-&gt;parent;</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="cf">while</span> (parent != NULL &amp;&amp; parent-&gt;color == RB_TREE_RED &amp;&amp; current-&gt;color == RB_TREE_RED) {</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="cf">if</span> (parent-&gt;parent == NULL) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="kw">struct</span> Node *uncle = get_uncle(current);</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="cf">if</span> (get_color(uncle) == RB_TREE_BLACK) {</a>
<a class="sourceLine" id="cb13-10" title="10">        <span class="cf">if</span> (get_direction(parent) != get_direction(current)) {</a>
<a class="sourceLine" id="cb13-11" title="11">            rotate(parent, get_direction(parent), rbtree);</a>
<a class="sourceLine" id="cb13-12" title="12">            current = parent;</a>
<a class="sourceLine" id="cb13-13" title="13">            parent = current-&gt;parent;</a>
<a class="sourceLine" id="cb13-14" title="14">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb13-15" title="15">            <span class="kw">struct</span> Node *grandparent = get_grandparent(current);</a>
<a class="sourceLine" id="cb13-16" title="16">            rotate(grandparent, !get_direction(parent), rbtree);</a>
<a class="sourceLine" id="cb13-17" title="17">            parent-&gt;color = RB_TREE_BLACK;</a>
<a class="sourceLine" id="cb13-18" title="18">            grandparent-&gt;color = RB_TREE_RED;</a>
<a class="sourceLine" id="cb13-19" title="19">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-20" title="20">        }</a>
<a class="sourceLine" id="cb13-21" title="21">    } <span class="cf">else</span> <span class="cf">if</span> (get_color(uncle) == RB_TREE_RED) {</a>
<a class="sourceLine" id="cb13-22" title="22">        color_flip(current);</a>
<a class="sourceLine" id="cb13-23" title="23">        <span class="cf">if</span> (parent-&gt;parent == NULL) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25">        <span class="kw">struct</span> Node *uncle = get_uncle(current);</a>
<a class="sourceLine" id="cb13-26" title="26">        current = get_grandparent(current);</a>
<a class="sourceLine" id="cb13-27" title="27">        parent = current-&gt;parent;</a>
<a class="sourceLine" id="cb13-28" title="28">    }</a>
<a class="sourceLine" id="cb13-29" title="29">}</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">rbtree-&gt;root-&gt;color = RB_TREE_BLACK;</a></code></pre></div>
<h2 id="löschen-von-knoten">Löschen von Knoten</h2>
<p>Die letzte Operation, die die Daten im Baum verändert, ist das Löschen von Knoten. Diese ist wohl auch die komplizierteste Operation, weil sehr viele Fälle betrachten muss und viele und Grenzfälle abfangen muss.</p>
<p>In meiner Implementierung findet das Löschen in 3 Schritten statt. Als erstes wird der Knoten, der gelöscht werden soll, mit einem Blatt des Baumes ausgetauscht, falls er noch keiner ist. Danach kann dieser sicher entfernt werden, ohne dass der Baum in mehrere Bäume zerfällt. Anschließend wird wieder die Balancierung durchgeführt. Alle diese Algorithmen wurden wieder in separate Funktionen extrahiert.</p>
<p>Die Funktion, die der Nutzer meiner Datenstruktur aufruft, um einen Knoten zu entfernen, heißt <code class="sourceCode c">delete_node</code>. Sie hat folgende Signatur:</p>
<pre><code>uint8_t delete_node(struct RBTree* rbtree, T* key);</code></pre>
<p><code class="sourceCode c">T* key</code> ist hier der Schlüssel des Knotens, der gelöscht werden soll.</p>
<p>Es wird damit begonne, dass der Knoten mit dem entsprechenden Schlüssel <code class="sourceCode c">key</code> gesucht wird. Dafür kann die <code class="sourceCode c">search</code>-Funktion verwendet werden, die im Kapitel <a href="#sea" data-reference-type="ref" data-reference="sea">3.3</a> etabliert wurde.</p>
<div class="sourceCode" id="cb15" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">struct</span> Node *node_to_delete = NULL;</a>
<a class="sourceLine" id="cb15-2" title="2">search_node(rbtree, key, &amp;node_to_delete);</a></code></pre></div>
<p>Als nächstes wird dann der Algorithmus durchgeführt, der den zu löschenden Knoten mit einem Blatt austauscht. Das Blatt, mit dem getauscht wird, wird so gewählt, dass nach der Löschung die Inorder-Traversierungs-Reihenfolge korrekt ist. Das alles wird durch die Funktion <code class="sourceCode c">swap_to_leaf</code> implementiert. Sie gibt dann den Pointer zum Blatt aus <code class="sourceCode c">x</code>, welches entfernt werden kann.</p>
<div class="sourceCode" id="cb16" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">struct</span> Node *x = swap_to_leaf(node_to_delete);</a></code></pre></div>
<p>Dann wird noch die <code class="sourceCode c">fix_tree_delete</code>-Funktion aufgerufen. Sie ist das Äquivalent zu <code class="sourceCode c">fix_tree_insert</code>, welche nach dem Einfügen den Baum balanciert, aber etwas komplizierter in ihrer Implementierung.</p>
<pre><code>fix_tree_delete(x, rbtree);</code></pre>
<p>Jetzt wird noch überprüft, ob die Wurzel gelöscht werden soll, was bedeutet, dass sie der einzige Knoten im Baum ist. Hier müssen dann einige Felder im <code class="sourceCode c">rbtree</code>-Struct verändert werden. Es werden dann alle Pointer, die auf den Knoten zeigen zu NULL geändert, was ihn effektiv aus dem Baum entfernt. Danach wird der zu löschende Knoten freigegeben.</p>
<div class="sourceCode" id="cb18" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="cf">if</span> (rbtree-&gt;root == x) {</a>
<a class="sourceLine" id="cb18-2" title="2">    _free_node(rbtree-&gt;root);</a>
<a class="sourceLine" id="cb18-3" title="3">    rbtree-&gt;root = NULL;</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="cf">return</span> RB_TREE_SUCCESS;</a>
<a class="sourceLine" id="cb18-5" title="5">}</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="cf">if</span> (get_direction(x) == RB_TREE_LEFT_CHILD) x-&gt;parent-&gt;left = NULL;</a>
<a class="sourceLine" id="cb18-8" title="8"><span class="cf">else</span> x-&gt;parent-&gt;right = NULL;</a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10">_free_node(x);</a></code></pre></div>
<p>Es wurden in diesem einführenden Abschnitt einige Funktionen genannt, die noch als Blackbox betrachtet wurden. Auf deren Funktionsweise wird in den nächsten Kapitel näher eingegangen.</p>
<h3 id="austauschen-mit-blatt">Austauschen mit Blatt</h3>
<p>Das Austauschen findet in der Funktion <code class="sourceCode c">swap_to_leaf</code> statt, deren Signatur sich im unteren Listing befindet.</p>
<pre><code>struct Node* swap_to_leaf(struct Node *node_to_delete);</code></pre>
<p><code class="sourceCode c">node_to_delete</code> ist dabei der Pointer zum Knoten der gelöscht werden soll von <code class="sourceCode c">delete_node</code> also somit der Knoten, der ein Blatt werden soll.</p>
<p>In der Funktion selbst muss nun der Knoten mit der oben genannten Eigenschaft gefunden werden. Dies geschiet, in dem man erst im linken Unterbaum von <code class="sourceCode c">node_to_delete</code> des Child sucht, welches sich am weitesten rechts befindet. Und falls es das nicht gibt sucht man im rechten Unterbaum nach dem Knoten, der sich am weitesten links befindet. Das sind die Knoten, die in der Inoreder-Reihenfolge direkt vor bzw. nach dem zu löschenden Knoten kommen. Das wird durch die Helfer-Funktionen <code class="sourceCode c">get_next_smallest</code> bzw. <code class="sourceCode c">get_next_largest</code>. Im unteren Listing kann man beispielhaft die Implementierung einer dieser Funktionen sehen:</p>
<div class="sourceCode" id="cb20" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">void</span> get_next_largest(<span class="kw">struct</span> Node *start, <span class="kw">struct</span> Node **next_largest)</a>
<a class="sourceLine" id="cb20-2" title="2">{</a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="kw">struct</span> Node *current  = start;</a>
<a class="sourceLine" id="cb20-4" title="4">    <span class="cf">while</span> (current-&gt;left != NULL) current = current-&gt;left;</a>
<a class="sourceLine" id="cb20-5" title="5">    *next_largest = current;</a>
<a class="sourceLine" id="cb20-6" title="6">}</a></code></pre></div>
<p>Wenn keiner der beiden oberen Fälle eintritt, dann ist <code class="sourceCode c">note_to_delete</code> bereits ein Leaf und der Algorithmus gibt den Knoten selbst aus.</p>
<p>Ansonsten werden mithilfe der Funktion <code class="sourceCode c">swap</code> die Schlüssen und Daten des Leafs und von <code class="sourceCode c">note_to_delete</code> einfach ausgetauscht und es wird der Pointer zum Leaf ausgegeben. Unten kann man die Implementierung für den Fall des linken Unterbaums sehen. Die für den rechten Unterbaum ist eine Aufgabe für den Leser.</p>
<div class="sourceCode" id="cb21" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">struct</span> Node *next_smallest =  NULL;</a>
<a class="sourceLine" id="cb21-2" title="2">get_next_smallest(node_to_delete-&gt;left, &amp;next_smallest);</a>
<a class="sourceLine" id="cb21-3" title="3">leaf = next_smallest;</a>
<a class="sourceLine" id="cb21-4" title="4">swap((<span class="dt">void</span>**)&amp;node_to_delete-&gt;key, (<span class="dt">void</span>**)&amp;next_smallest-&gt;key);</a>
<a class="sourceLine" id="cb21-5" title="5">swap(&amp;node_to_delete-&gt;value, &amp;next_smallest-&gt;value);</a></code></pre></div>
<h3 id="balancieren-des-baumes-löschen">Balancieren des Baumes (Löschen)</h3>
<h2 id="tr">Generische Baumtraversierung</h2>
<p>Wie schon in der Einleitung erwähnt, bieten <span data-acronym-label="bt" data-acronym-form="plural+short">bts</span> die Möglichkeit, Daten geordnet zu speichern. Nun benötigt man auch Möglichkeiten, auf die Daten in einer bestimmten Reihenfolge zuzugreifen. Grundsätzlich gibt es 3 Optionen, die man als <span data-acronym-label="tv" data-acronym-form="singular+short">tv</span> bezeichnet nämlich Inorder-, Preorder- und Postorder-Traversierung. Alle diese Algorithmen sind rekursiv definiert. <span class="citation" data-cites="aic"></span> Der untere <span data-acronym-label="psc" data-acronym-form="singular+short">psc</span> stellt dar, wie sie funktionieren.</p>
<p>VISIT(noteptr) PREORDER(noteptr<span class="math inline">→</span>left) PREORDER(noteptr<span class="math inline">→</span>right) INORDER(noteptr<span class="math inline">→</span>left) VISIT(noteptr) INORDER(noteptr<span class="math inline">→</span>right) POSTORDER(noteptr<span class="math inline">→</span>left) POSTORDER(noteptr<span class="math inline">→</span>right) VISIT(noteptr)</p>
<p><span class="citation" data-cites="aop"></span></p>
<p>Dabei ist <code class="sourceCode c">noteptr</code> der Pointer der Wurzel des Unterbaums (der ganze Baum ist auch ein Unterbaum von sich selbst). Und <code class="sourceCode c">VISIT</code> stellt dabei eine Funktionspointer dar, der einen <code class="sourceCode c">noteptr</code> als Parameter akzeptiert und ebenfalls als Argument in die Traversierungsfunktionen gegeben wird. So ist es dem Nutzer möglich, eine bestimmte Funktion auf alle Knoten anzuwenden.</p>
<div class="sourceCode" id="cb22" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">uint8_t</span> inorder_traversel(<span class="kw">struct</span> RBTree *rbtree, <span class="dt">void</span> (*visit)(<span class="kw">struct</span> Node*))</a>
<a class="sourceLine" id="cb22-2" title="2">{</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="kw">struct</span> Node *current = rbtree-&gt;root;</a>
<a class="sourceLine" id="cb22-4" title="4">    <span class="kw">struct</span> Stack *stack = create_stack(_calc_worst_case_height(rbtree));</a>
<a class="sourceLine" id="cb22-5" title="5"></a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="cf">while</span> (current != NULL || !is_stack_empty(stack)) {</a>
<a class="sourceLine" id="cb22-7" title="7">        <span class="cf">if</span> (current != NULL) {</a>
<a class="sourceLine" id="cb22-8" title="8">            push(stack, current);</a>
<a class="sourceLine" id="cb22-9" title="9">            current = current-&gt;left;</a>
<a class="sourceLine" id="cb22-10" title="10">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb22-11" title="11">            <span class="kw">struct</span> Node *stack_node;</a>
<a class="sourceLine" id="cb22-12" title="12">            pop(stack, &amp;stack_node);</a>
<a class="sourceLine" id="cb22-13" title="13">            visit(stack_node);</a>
<a class="sourceLine" id="cb22-14" title="14">            current = stack_node-&gt;right;</a>
<a class="sourceLine" id="cb22-15" title="15">        }</a>
<a class="sourceLine" id="cb22-16" title="16">    }</a>
<a class="sourceLine" id="cb22-17" title="17">    free_stack(stack);</a>
<a class="sourceLine" id="cb22-18" title="18">    <span class="cf">return</span> RB_TREE_SUCCESS;</a>
<a class="sourceLine" id="cb22-19" title="19">}</a></code></pre></div>
<p>Im oberen Listing kann man am Beispiel der Inorder-Traversierung erkennen, wie die Algorithmen iterativ implementiert wurden. Anstatt den Hardware-<span data-acronym-label="st" data-acronym-form="singular+short">st</span> zu verwenden, wurde ein Software-<span data-acronym-label="st" data-acronym-form="singular+short">st</span> <code class="sourceCode c"><span class="kw">struct</span> Stack *stack</code> implementiert. In diesen werden jeweils die noch zu besuchenden Unterbäume gepushed, und wenn der aktuelle Knoten <code class="sourceCode c">current</code> <code class="sourceCode c">NULL</code> ist, wird ein neuer Knoten aus dem <span data-acronym-label="st" data-acronym-form="singular+short">st</span> geholt. Diese Vorgehen simuliert das verhalten einer rekusiven Funktion, jedoch besteht bei sehr großer <span data-acronym-label="rcd" data-acronym-form="singular+short">rcd</span> nicht die Möglichkeit eines <span data-acronym-label="sof" data-acronym-form="singular+short">sof</span>. Die anderen Traversierungsarten wurden auf die selbe Weise implementiert.</p>
<p>Es kommt auf die genutzte Traversierungsart an, in welcher Reihenfolge man die Knoten besucht. Wenn man Inorder nutzt, dann bekommt man sie nach Schlüsseln aufsteigend sortiert. Das kann man z.B. dafür nutzen, die Schlüssel in geordneter Reihenfolge auszugeben. Bei der Postorder Traversierung wird die Wurzel des Unterbaums als besucht. So kann man Bottom-Up-Algorithmen implementieren, die bei den Blättern beginnen und die Wurzel des Baums als letztes behandeln.</p>
<p>Ein sehr praktischen Bespiel dafür ist das Freigeben der <span data-acronym-label="rbt" data-acronym-form="plural+short">rbts</span>. Dabei müssen zuerst die Unterbäume aus dem <span data-acronym-label="hp" data-acronym-form="singular+short">hp</span> gelöscht werden und danach die Wurzel, weil man sonst die Unterbäume zwischenspeichern müsste, da die Pointer zu ihnen in der Wurzel gespeichert sind. Wenn man diese aber nun als erster freigibt, würde man keinen Zugriff mehr auf ihre Unterbäume haben.</p>
<div class="sourceCode" id="cb23" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> _free_node(<span class="kw">struct</span> Node *node)</a>
<a class="sourceLine" id="cb23-2" title="2">{</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="cf">if</span> (node-&gt;key != NULL) free(node-&gt;key);</a>
<a class="sourceLine" id="cb23-4" title="4">    <span class="cf">if</span> (node-&gt;value != NULL) free(node-&gt;value);</a>
<a class="sourceLine" id="cb23-5" title="5">    free(node);</a>
<a class="sourceLine" id="cb23-6" title="6">}</a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="dt">void</span> free_tree(<span class="kw">struct</span> RBTree *rbtree)</a>
<a class="sourceLine" id="cb23-9" title="9">{</a>
<a class="sourceLine" id="cb23-10" title="10">    postorder_traversel(rbtree, &amp;_free_node);</a>
<a class="sourceLine" id="cb23-11" title="11">    free(rbtree);</a>
<a class="sourceLine" id="cb23-12" title="12">}</a></code></pre></div>
<p>Hier wurde die <code class="sourceCode c">VISIT</code>-Funktion als <code class="sourceCode c">_free_node</code> implementiert, welche den Schlüssel und den Wert des besuchten Knotens freigibt und dann den Knoten-<span data-acronym-label="sts" data-acronym-form="singular+short">sts</span> selbst.</p>
<h2 id="err">Fehlerbehandlung</h2>
<p>Wie man in vielen vorhergenden Listings bereits sehen konnte, haben die meisten Funktionen als Ausgabetypen <code class="sourceCode c"><span class="dt">uint8_t</span></code>. (Die Fehlerbehandlung wurde aus den Listings jedoch meistens weggelassen, damit die sie nicht zu lang werden.) Das liegt, dass die Funktionen über den Ausgabewert Fehler an den Nutzer zurückgeben. Diese Fehler wurden als <span data-acronym-label="mc" data-acronym-form="singular+short">mc</span> definiert und durch sie können verschiedene Arten unterschieden werden.</p>
<div class="sourceCode" id="cb24" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="pp">#define RB_TREE_SUCCESS             0U</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="pp">#define RB_TREE_OUT_OF_MEM          1U</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="pp">#define RB_TREE_KEY_ERROR           2U</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="pp">#define RB_TREE_NULL_ERROR          3U</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="pp">#define RB_TREE_DUPLICATE_KEY_ERROR 4U</span></a></code></pre></div>
<p>In meiner Implementierung repräsentiert die 0 immer, dass es keinen Fehler gab. <code class="sourceCode c">RB_TREE_OUT_OF_MEM</code> wird von Funktionen verwendet, die dynamisch Speicher allozieren und das Betriebssystem nicht mehr genug zur Verfügung stellt. Die einzige Funktion, die den Fehler nutzt, ist <code class="sourceCode c">insert_node</code>, nämlich genau dann, wenn kein neuer Knoten erstellt werden kann. Hierbei wird der Fehler allerdings nicht ausgegeben, sondern das Program wird mit <code class="sourceCode c">exit(RB_TREE_OUT_OF_MEM)</code> beendet. Ein <code class="sourceCode c">RB_TREE_KEY_ERROR</code> wird von <code class="sourceCode c">search_node</code> ausgegeben, wenn der zu suchende Schlüssel im Baum nicht existiert. Funktionen, die Pointer als Argumente akzeptieren, geben einen <code class="sourceCode c">RB_TREE_NULL_ERROR</code> Fehler aus, wenn mindestens einer dieser Pointer <code class="sourceCode c">NULL</code> ist. Und ein <code class="sourceCode c">RB_TREE_DUPLICATE_KEY_ERROR</code> wird ausgegeben, wenn man <code class="sourceCode c">insert_node</code> einen Schlüssel übergibt, der bereits im Baum existiert und man doppelte Schlüssel und implizites Überschreiben mithilfe der <code class="sourceCode c">RB_TREE_DUPLICATE_KEYS</code> <span data-acronym-label="mc" data-acronym-form="singular+short">mc</span> deaktiviert hat.</p>
<h1 id="implementierungsvarianten">Implementierungsvarianten</h1>
<h1 id="benchmarks">Benchmarks</h1>
<h1 id="time">Speicher- und Zeitkomplexität</h1>
<h1 id="verwendung">Verwendung</h1>
<p>2ex</p>
